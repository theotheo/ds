# Синтаксис


## Объектная модель

- данные представлены в виде объекты
- либо встроенные объекты, либо, которые мы создаем с применением классов Python или внешних языковых инструментов, таких как библиотеки расширений С. 
- объекты представляют собой порции памяти со значениями и наборами связанных операций
- в Python абсолютно все является объектами
- ...

## почему
> Если вы имели дело с языком более низкого уровня наподобие С или C++, то знаете, что большая часть работы сконцентрирована на реализации обзехшо#, также известных, как структуры данных, для представления компонентов в вашей предметной области. Вам нужно планировать структуры в памяти, управлять выделением памяти, создавать процедуры поиска и доступа и т.д. Такие рутинные задачи утомительны (и чреваты ошибками) и они зачастую отвлекают от истинных целей программы
-- Лутц

.Встроеные объекты:
. облегчают написание программ. 
. являются компонентами расширений
. часто эффективнее специальных структур данных
. представляют собой стандартную часть языка. 
. являются более мощными и эффективными, чем большинство того,
что можно создать с нуля. 


## !
image::2019-10-01-16-53-25.png[]

## особенности
- программные единицы — функции, модули и классы -- объекты. 
- Они создаются посредством операторов и выражений вроде def, class, import и lambda
- могут свободно передаваться между сценариями, храниться внутри других объектов и т.д.


- "набор типов, связанных с реализацией, таких как объекты скомпилированного кода, которые обычно представляют
больший интерес для создателей инструментов, чем для разработчиков приложений;"


## основные типы (built-ins)
Основными типами данных -- фактически встроены в язык -- для генерации
большинства из них имеется специфический синтаксис выражений. 
Например, 'python' -- т.н. литеральное выражение (литерал), которое генерирует и возвращает новый объект строки. Т.е. есть специальный синтаксис. Для словаря, списка -- аналогично есть специальный синтаксис

## динамическая типизация
 после того, как объект создан, он навсегда привязывается к своему набору операций; на строке можно выполнять только строковые операции, а на списке — только списковые операции. Формально это означает, что язык
Python динамически типизирован — модель, которая отслеживает типы автоматически,
не требуя объявления, но он также строго типизирован — ограничение, обусловливающее возможность выполнения на объекте только допустимых для его типа операций

## Числа
- создание
- операции

## Переменные
- ярлыки

## строки
- создание
- операции
- строка -- это последовательность
- строка -- неизменяемый

## списки
- последовательность
- изменяемый
- создание
- операции
- бесконечная вложенность
- list comprehension

## словари
- отображение (map)
- изменяемый
- создание
- операции
- бесконечная вложенность
- dict comprehension

## bool
- True/False

## None

## кортежи
- последовательность
- неизменяемые
- создание
- операции

## файлы
- создание
- операции
- бинарные или текстовые
- eval, pickle

## коллекции
- immutable vs mutable
- итерируемые vs неитерируемые

[.stretch]
image::2019-10-01-17-23-13.png[]


## Класс объекты
- type
- type(type)

## иерархия
image::https://upload.wikimedia.org/wikipedia/commons/1/10/Python_3._The_standard_type_hierarchy.png[]




## проверка типов

## полиморфизм

Выполняя проверку на предмет специфического типа в своем коде, вы фактически нарушаете гибкость кода — ограничиваете его работой только с одним типом. Без такой проверки код может быть способен работать с целым диапазоном типов.
Все связано с упоминаемой ранее идеей полиморфизма и уходит своими корнями
в отсутствие в Python объявлений типов. Как вы узнаете, в Python мы имеем дело с
интерфейсами объектов (поддерживаемыми операциями), а не с типами. Другими словами нас заботит, что объект делает, а не чем он является. 

> полиморфизм — вероятно, ключевая идея правильного использования Python
-- Лутц

## duck typing

> "If it walks like a duck and it quacks like a duck, then it must be a duck"
-- https://en.wikipedia.org/wiki/Duck_typing

[.stretch]
image::https://media1.tenor.com/images/6ab9b4020baa286f787189885a26e6fe/tenor.gif?itemid=11392557[]

## Свой класс
> Объектно-ориентированное программирование на Python — необязательное, но мощное средство языка, которое сокращает время разработки за счет поддержки программирования через настройку. В общих понятиях классы определяют новые типы объектов, которые расширяют основной набор. 
-- Лутц

## Другие классы
> Остальные типы в Python будут либо объектами, связанными с
выполнением программ (наподобие функций, модулей, классов и скомпилированного кода), которые мы исследуем позже, либо реализуются функциями импортированных модулей, а не синтаксисом языка. Последние также имеют тенденцию исполнять
роли, специфичные для приложения — образцы текста, интерфейсы к базам данных,
сетевые подключения и т.д

-- Лутц


## Иерархия кода

----
программы Python могут быть разложены на модули, операторы, выражения и объекты, как описано ниже.
1. Программы состоят из модулей.
2. Модули содержат операторы.
3. Операторы содержат выражения.
4. Выражения создают и обрабатывают объекты.
----
-- Лутц


// Выражения и операторы: https://www.quora.com/Whats-the-difference-between-a-statement-and-an-expression-in-Python-Why-is-print-%E2%80%98hi%E2%80%99-a-statement-while-other-functions-are-expressions
// Выражения состоят из операторов
// https://docs.python.org/3/reference/expressions.html
// https://python.swaroopch.com/op_exp.html


## Операторы

[.stretch]
image::2019-10-01-17-39-31.png[]

## Операторы
[.stretch]
image::2019-10-01-17-40-07.png[]

## Отступы
[source]
----
Строка заголовка:
    Вложенный блок операторов
----

https://en.wikipedia.org/wiki/Off-side_rule

## control structures

## if
[.stretch]
image::https://files.realpython.com/media/t.78f3bacaa261.png[]
https://realpython.com/python-conditional-statements/

## while
[.stretch]
image::https://files.realpython.com/media/t.899f357dd948.png[]

- интерактивные пример с while True
- вложенные циклы

## for
image::https://files.realpython.com/media/t.ba63222d63f5.png[]
https://realpython.com/python-for-loop/




